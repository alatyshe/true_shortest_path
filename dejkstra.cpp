#include <iostream.h>
#include <conio.h>
#include <windows.h>
#include<iomanip.h>
    
    int v;
    int i, j;
                                            // Количество вершин в графе
    int VES[100][100];                      // Матрица весов графа
 
    int x[100];                             //Массив, содержащий единицы и нули для каждой вершины,
                                            // x[i]=0 - еще не найден кратчайший путь в i-ю вершину,
                                            // x[i]=1 - кратчайший путь в i-ю вершину уже найден
   
    int DlinaPuti[100];                     // t[i] - длина кратчайшего пути от вершины start в i

    int PredVertex[100];                    // h[i] - вершина, предшествующая i-й вершине
                                            // на кратчайшем пути
    int VERTEX;
    int total_veshin;                                  // количество вершин

 
    // Будем искать путь из вершины start в вершину g по циклу
    int start;                              // Номер исходной вершины
    int end;                                // Номер конечной вершины


    // Обнуляем начальные значения массивов
    for (int i = 0; i < total_veshin; i++)
    {
        DlinaPuti[i] = 2147483647;          //Сначала все кратчайшие пути из start в i равны бесконечности
        x[i] = 0;                           // и нет кратчайшего пути ни для одной вершины
    }
    PredVertex[start] = 0;                  // start - начало пути, поэтому этой вершине ничего не предшествует
    DlinaPuti[start] = 0;                   // Кратчайший путь из start в start равен 0
    x[start] = 1;                           // Для вершины start найден кратчайший путь
    v = start;                              // Делаем start текущей вершиной
   
   while(1)
   {
                                            // Перебираем все вершины, смежные v, и ищем для них кратчайший путь
      for(u = 0; u < total_veshin; u++)
      {
         if (VES[v][u] == 0)                // Вершины u и v несмежные
          continue;

         if (x[u] == 0 && DlinaPuti[u] > DlinaPuti[v] + VES[v][u]) //Если для вершины 'u' еще не
          //найден кратчайший путь и новый путь в 'u' короче чем старый, то
         {
            DlinaPuti[u] = DlinaPuti[v] + VES[v][u]; //запоминаем более короткую длину пути в массив t[и]
            PredVertex[u] = v;              //запоминаем, что v->u часть кратчайшего пути из s->u
         }
      }
 
                                            // Ищем из всех длин некратчайших путей самый короткий
      int w = 2147483647;                   // Для поиска самого короткого пути
      v = -1;                               // В конце поиска v - вершина, в которую будет 
                                            // найден новый кратчайший путь. Она станет 
                                            // текущей вершиной
      for(u = 0; u < total_veshin; u++)     // Перебираем все вершины.
      {
         if(x[u] == 0 && DlinaPuti[u] < w)  // Если для вершины не найден кратчайший 
                                            // путь и если длина пути в вершину 'u' меньше уже найденной, то
         {
            v = u;                          // текущей вершиной становится 'u'-я вершина
            w = DlinaPuti[u];
         }
      }








      if(v==-1)
      {
         cout<<RUS("Нет пути из вершины ")<<start+1;cout<<RUS(" в вершину ")<<end+1<<"."<<endl;
         break;
      }
      if(v==end)                        // Найден кратчайший путь,
      {                                 // выводим его
         cout<<RUS("Кратчайший путь из вершины ")<<start+1;cout<<RUS(" в вершину ")<<end+1<<":";
       u=end;
       while(u!=start)
         {
            cout<<" "<<u+1;
            u=PredVertex[u];
         }
         cout<<" "<<start+1<<RUS(". Длина пути - ")<< DlinaPuti[end];cout<<endl;
       break;
      }
      x[v]=1;
   }}
